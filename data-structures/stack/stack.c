/*
    X --------------------------------------- X
    |  Задача (усложняю себе жизнь, часть 2)  |
    X --------------------------------------- X 
    Реализовать  на  основе односвязного списка 
    библиотеку  стека на языке С без каких-либо
    гайдов,  основываясь  лишь на знаниях того,
    как  работают  сегменты  памяти  процесса и
    стандарт  языка. Я  изобретаю велосипед, но
    делаю  это не по велосипедистским журналам,
    а  по учебникам физики и сварке. Это круто.
              𓆞 𓆝 𓆟 𓆝 𓆟 𓆞 𓆝 𓆟
    Комментарии  нужны, чтобы подмечать те или
    иные решения, к которым пришел сам.
*/
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include "stack.h"

Stack createStack()
{
    /*
        Функция  возвращает  что-то  вроде  дескриптора стека, который
        используется  во  всех  функциях  библиотеки. Дескриптор стека
        может  указывать  на NULLPTR, и это не будет являться ошибкой.
        Я использую NULLPTR, чтобы отличать пустой стек от не пустого.
        Во всех остальных функциях производятся проверки.
    */
    
    // Комментариев больше, чем кода  ദ്ദി •⩊• )
    return NULL;
}

int isEmptyStack(Stack* s)
{
    return s == NULL ? 1 : 0;
}

int pushStack(Stack* s, int64_t value)
{
    /*
        Выделяю  память  под новую ноду стека и присваиваю при помощи
        указателя  на  указатель  дескриптору ссылку на новую верхнюю
        ноду стека, которая указывает при помощи поля next на старую.
    */
    _StackNode* node = (_StackNode*)malloc(sizeof(_StackNode));

    if (node == NULL) {
        return STACKLIB_MALLOC_ERROR;
    }

    node->value = value;
    node->next = *s;
    *s = node;

    return 0;
}

int64_t popStack(Stack* s)
{
    /*
        Дескриптор  стека  теперь  указывает  на ниже лежащую ноду,
        а  предыдущая очищается из кучи и возвращается ее значение.
    */
    _StackNode* lastNode = *s;
    int64_t result = lastNode->value;

    _StackNode* nextNode = lastNode->next;
    *s = nextNode;
    free(lastNode);

    return result;
}

void freeStack(Stack* s)
{
    _StackNode* tmp;

    while (*s != NULL) {
        tmp = *s;
        *s = (*s)->next;
        free(tmp);
    }
}