### О мини-проекте
Это версия недавно написанного стека на чистом С без использования каких-либо
статей с готовой реализацией, Stack Overflow или ChatGPT в стиле псевдо 
объектно-ориентированного программирования.

В отличие от прошлой трушной процедурной версии, здесь также реализован односвязный
список в структуре StackNode, однако в качестве контейнера поверх этой структуры
играет не просто указатель на самую верхнюю ноду стека, а полноценный объект,
роль которого выполняет структура StackObject.

StackObject создается при помощи конструктора createStack(), возвращающего объект
стека с двумя приватными полями и пятью методами, взаимодействующими с данным
объектом при помощи поля self.

### Чему я научился в мини-проекте?

- В этом мини-проекте окончательно закрепил тему сегментов памяти процесса.
- Изучил указатели на функции.

### Документация
---

Функция `createStack()` создает объект стека и возвращает на него указатель типа. Для этого используется тип `Stack`. Пример использования:

```c
int main()
{
    Stack stackObj = createStack();

    return 0;
}
```

Объект стека содержит приватные поля, начинающиеся с нижнего подчеркивания. **Любые поля библиотеки, начинающиеся с нижнего подчеркивания, нельзя использовать & вызывать**.

#### Методы объекта Stack
Все методы требуют передачу объекта первым параметром, т. к. в С нельзя сделать это неявно.

**size_t size(Stack self)**
```c
Stack stackObj = createStack();
stackObj->size(stackObj);        // Вернет 0. Элементы не были еще добавлены

stackObj->push(stackObj, 1);
stackObj->size(stackObj);        // Вернет 1
```

**bool isEmpty(Stack self)**
```c
Stack stackObj = createStack();
stackObj->isEmpty();             // Вернет true
```

**bool push(Stack self, int64_t value)**
```c
Stack stackObj = createStack();

// Создаст ноду односвязного списка. В приватном поле 
// stackObj->_top будет хранится адрес этой ноды
stackObj->push(stackObj, 69); 

stackObj->size(stackObj);        // Вернет 1
stackObj->isEmpty(stackObj);     // Вернет false
```

**int64_t pop(Stack self)**
```c
Stack stackObj = createStack();
stackObj->push(stackObj, 69);

// Вернет число 69, удалит из памяти эту ноду, а также
// сместит указатель stackObj->_top ниже, если нода не последняя
stackObj->pop(stackObj);
```

**void delete(Stack\* self)**
```c
Stack stackObj = createStack();

// Передается АДРЕС объекта Stack!!! Это нужно для того, чтобы
// автоматически после очистки присвоить ему нулевой указатель
stackObj->delete(&stackObj);

printf("%d", stackObj == NULL);  // Вернет 1
```